// Config
Size canvasSize = new Size(1000, 700);
Size nodeSize = new Size(15, 30);
Size nodeGapSize = new Size(2, 3);
Size fileSize = new Size(10, 10);
float replSpeed = 10.0;
float brightSpeed = 10;
float fadeoutSpeed = 10;
colorMode(RGB, 255);
color strokeColor = color(0, 0, 0, 0);
color backgroundColor = color(150, 200, 255);
color nodeColor = color(255, 255, 255);


// Global variables
ArrayList fileList = new ArrayList();


// Classes
class Size {
    int width, height;
    Size(int _width, int _height) {
        width = _width;
        height = _height;
    }
}


class Pos {
    int x, y;
    Pos(int _x, int _y) {
        x = _x;
        y = _y;
    }
}

class File {
    String name;

    // State
    boolean replicationStarting, replicating, removing;

    // brightness (0-255)
    int brightness;

    // Current position
    Pos curPos;
    String curCluster;  // null on replicating
    int curLocalId;     // null on replicating

    // property for when making replica
    Pos srcPos;
    String srcCluster;
    int srcLocalId;
    Pos destPos;
    String destCluster;
    int destLocalId;

    // Constructor for replica
    File(String _name,
         String _srcCluster, int _srcLocalId,
         String _destCluster, int _destLocalId) {
        replicationStarting = true;
        replicating = false;
        removing = false;

        brightness = 0;

        name = _name;
        curCluster = null;
        curLocalId = -1;
        srcCluster = _srcCluster;
        srcLocalId = _srcLocalId;
        destCluster = _destCluster;
        destLocalId = _destLocalId;

        srcPos = getNodePos(srcCluster, srcLocalId);
        srcPos.x += int(nodeSize.width / 2);
        srcPos.y += int(nodeSize.height / 2);
        if (name.charAt(name.length() - 1) == "A") {
            srcPos.y -= int(nodeSize.height / 3);
        } else if (name.charAt(name.length() - 1) == "B") {
        } else if (name.charAt(name.length() - 1) == "C") {
            srcPos.y += int(nodeSize.height / 3);
        }

        curPos = srcPos;

        destPos = getNodePos(destCluster, destLocalId);
        destPos.x += int(nodeSize.width / 2);
        destPos.y += int(nodeSize.height / 2);
        if (name.charAt(name.length() - 1) == "A") {
            destPos.y -= int(nodeSize.height / 3);
        } else if (name.charAt(name.length() - 1) == "B") {
        } else if (name.charAt(name.length() - 1) == "C") {
            destPos.y += int(nodeSize.height / 3);
        }
    }

    // Constructor for static file
    File(String _name,
         String _curCluster, int _curLocalId) {
        replicationStarting = false;
        replicating = false;
        removing = false;

        brightness = 0;

        name = _name;

        curCluster = _curCluster;
        curLocalId = _curLocalId;
        srcCluster = null;
        srcLocalId = -1;
        destCluster = null;
        destLocalId = -1;

        curPos = getNodePos(curCluster, curLocalId);
        curPos.x += int(nodeSize.width / 2);
        curPos.y += int(nodeSize.height / 2);
        if (name.charAt(name.length() - 1) == "A") {
            curPos.y -= int(nodeSize.height / 3);
        } else if (name.charAt(name.length() - 1) == "B") {
        } else if (name.charAt(name.length() - 1) == "C") {
            curPos.y += int(nodeSize.height / 3);
        }

        srcPos = null;
        destPos = null;
    }

    // This function is supposed to be called every frame
    void updateAndDraw() {
        if (removing && replicating) {
            // Assertion failed
            triangle(30, 75, 58, 20, 86, 75);
            exit();
        }
        // Removing cannot be supported since
        // files are eliminated from fileList
        // soon after action=rm is digested
        // else if (removing) {
        // }
        else if (replicationStarting) {
            // Flush the file
            if (0 <= brightness && brightness <= 255) {
                brightness += brightSpeed;
                // Draw start position
                fill(getColorForFile(name));
                stroke(strokeColor);
                ellipse(curPos.x, curPos.y, fileSize.width, fileSize.height);
                // Draw brightness
                fill(255, 255, 64, brightness);
                noStroke(strokeColor);
                ellipse(curPos.x, curPos.y, fileSize.width + 3, fileSize.height + 3);
            } else if (255 < brightness) {
                brightness = 0;
                replicationStarting = false;
                replicating = true;
            } else {
                println("Brightness assertion failed!");
            }
        }
        else if (replicating) {
            // Overwrite previous position
            fill(backgroundColor);;
            noStroke();
            ellipse(curPos.x, curPos.y, fileSize.width + 3, fileSize.height + 3);
            stroke(strokeColor);

            float norm = distance(destPos, srcPos);
            curPos.x += float(destPos.x - srcPos.x) * replSpeed / norm;
            curPos.y += float(destPos.y - srcPos.y) * replSpeed / norm;
            // When curPos overruns destPos
            if (distance(destPos, curPos) <= replSpeed) {
                curPos = destPos;
                srcPos = destPos = null;
                replicating = false;
            }
            // Draw new position
            fill(getColorForFile(name));
            ellipse(curPos.x, curPos.y, fileSize.width, fileSize.height);
        }
        else {
            fill(getColorForFile(name));
            ellipse(curPos.x, curPos.y, fileSize.width, fileSize.height);
        }
    }

    boolean remove() {
        if (replicating) {
            return false;
        }
        removing = true;
        return true;
    }
}


// Main functions (setup/draw)
void setup() {
    size(canvasSize.width, canvasSize.height);
    frameRate(24);
    background(backgroundColor);
    stroke(strokeColor);
}
void draw() {
    // initialize fileList only 1 time in browser
    if (readyToInitFileList == true) {
        initializeFileList();
        readyToInitFileList = false;
    }
    updateFileList();
    drawClusters();
    drawFiles();
}


// File list update
void initializeFileList() {
    for (var tracedFileName in mdInfo) {
        var tracedFileContents = mdInfo[tracedFileName];
        tracedFileContents.split('\n').map(function(line) {
            var mdInfoHash = mdInfoLine2mdInfoHash(line);
            if (mdInfoHash != undefined) {
                var ip = mdInfoHash['ip'];
                fileList.add(new File(tracedFileName,
                                      iptable[ip]['cluster'],
                                      iptable[ip]['localId']));
            }
        });
    }
}
// Process movement requests
void updateFileList() {
    fill(backgroundColor);
    rect(0, 0, 30, 30);
    fill(0);
    text(fileList.size(), 10, 10);
    for (var i = 0; i < mvmntReqQ.length; i++) {
        var mvmntReq = mvmntReqQ.pop();
        if (mvmntReq['action'] == 'repl') {
            fileList.add(new File(mvmntReq['name'],
                                  mvmntReq['srcCluster'], mvmntReq['srcLocalId'],
                                  mvmntReq['destCluster'], mvmntReq['destLocalId']));
        }
        else if (mvmntReq['action'] == 'rm') {
            for (int i = 0; i < fileList.size(); i++) {
                if (fileList.get(i).name == mvmntReq['name'] &&
                    fileList.get(i).curCluster == mvmntReq['cluster'] &&
                    fileList.get(i).curLocalId == mvmntReq['localId']) {
                    if (fileList.get(i).remove()) {
                        fileList.remove(i);
                    }
                    break;
                }
            }
        }
    }
}


// Draw functions
// They are supposed to be called every frame
void drawClusters() {
    fill(nodeColor);
    stroke(strokeColor);
    for (var clusterName in clusterGeo) {
        var c = clusterGeo[clusterName];
        for (var iVertical = 0; iVertical <= c['maxVerticalNum']; iVertical++) {
            for (var iHorizontal = 0; iHorizontal <= c['maxHorizontalNum']; iHorizontal++) {
                Pos nodePos = getNodePos(clusterName, iVertical*100 + iHorizontal);
                rect(nodePos.x, nodePos.y,
                     nodeSize.width, nodeSize.height);
            }
        }
    }
}

void drawFiles() {
    for (int i = 0; i < fileList.size(); i++) {
        fileList.get(i).updateAndDraw();
    }
}

float distance(Pos a, Pos b) {
    return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));
}

/*
@parameter
clusterName: 'huscs'
localId: 1 (for '001')

@returns
Pos object
*/
Pos getNodePos(clusterName, localId) {
    String c = clusterGeo[clusterName];
    Pos centerOfCluster = new Pos(c["maxHorizontalNum"] / 2,
                                  c["maxVerticalNum"] / 2);
    return new Pos(
        canvasSize.width * c['posX'] + (localId%100 - centerOfCluster.x) * (nodeSize.width + nodeGapSize.width),
        canvasSize.height * c['posY'] + (int(localId/100) - centerOfCluster.y) * (nodeSize.height + nodeGapSize.height)
    );
};

int encodeStr(String s) {
    if (s.charAt(s.length() - 1) == "A") return 1;
    else if (s.charAt(s.length() - 1) == "B") return 2;
    else if (s.charAt(s.length() - 1) == "C") return 3;
    else println("Unexpected trace file name!!");
}

color getColorForFile(String fileName) {
    int code = encodeStr(fileName);
    if (code == 1) return color(255, 128, 128, 255);       // traceA -> Red
    else if (code == 2) return color(128, 255, 128, 255);  // traceB -> Green
    else if (code == 3) return color(128, 128, 255, 255);  // traceC -> Blue
}
